#!/usr/bin/env bash
# This script was generated by bashly 1.1.8 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
pm_usage() {
  if [[ -n $long_usage ]]; then
    printf "pm - Project manager built on top of tmux\n"
    echo

  else
    printf "pm - Project manager built on top of tmux\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  pm COMMAND\n"
  printf "  pm [COMMAND] --help | -h\n"
  printf "  pm --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Show help about a command\n" "help  "
  printf "  %s   Space related commands\n" "space "
  printf "  %s   Create a link to the recipe script\n" "link  "
  printf "  %s   Remove the link to the recipe script\n" "unlink"
  printf "  %s   Update to the latest version\n" "update"
  printf "  %s   Show environment information\n" "env   "
  echo
  printf "%s\n" "Project Commands:"
  printf "  %s   Create a new empty project\n" "new   "
  printf "  %s   Clone a remote git repository\n" "clone "
  printf "  %s   Open a project\n" "open  "
  printf "  %s   Filter projects by name\n" "filter"
  printf "  %s   List projects\n" "list  "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "PM_INSTALL_DIR"
    printf "    Directory where the repository was cloned\n"
    printf "    Default: ${HOME}/.pm\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "PM_HOME"
    printf "    Directory where the projects will be managed\n"
    printf "    Default: ${HOME}/dev\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "PM_BACKEND"
    printf "    Script executed to open the project\n"
    printf "    Default: ${PM_INSTALL_DIR}/backends/tmux.sh\n"
    echo

  fi
}

# :command.usage
pm_help_usage() {
  if [[ -n $long_usage ]]; then
    printf "pm help - Show help about a command\n"
    echo

  else
    printf "pm help - Show help about a command\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  pm help [COMMAND]\n"
  printf "  pm help --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "COMMAND"
    printf "    Help subject\n"
    echo

  fi
}

# :command.usage
pm_new_usage() {
  if [[ -n $long_usage ]]; then
    printf "pm new - Create a new empty project\n"
    echo

  else
    printf "pm new - Create a new empty project\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  pm new NAME [OPTIONS]\n"
  printf "  pm new --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--space, -s SPACE (required)"
    printf "    Space of the new project\n"
    echo

    # :flag.usage
    printf "  %s\n" "--template, -t TEMPLATE"
    printf "    Name of the template\n"
    printf "    Default: default\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Name of the new project\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  pm new recipe --space tools\n"
    printf "  pm new recipe --template cargo --space tools\n"
    echo

  fi
}

# :command.usage
pm_clone_usage() {
  if [[ -n $long_usage ]]; then
    printf "pm clone - Clone a remote git repository\n"
    echo

  else
    printf "pm clone - Clone a remote git repository\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  pm clone REPOSITORY [OPTIONS]\n"
  printf "  pm clone --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--space, -s SPACE (required)"
    printf "    Space to clone the project in\n"
    echo

    # :flag.usage
    printf "  %s\n" "--name, -n NAME"
    printf "    Name to clone the project as\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "REPOSITORY"
    printf "    Remote repository to clone (FORMAT: <username>/<repository>)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  pm clone alexis-moins/recipe --space tools\n"
    printf "  pm clone neovim/neovim --space tools --name editor\n"
    echo

  fi
}

# :command.usage
pm_open_usage() {
  if [[ -n $long_usage ]]; then
    printf "pm open - Open a project\n"
    echo

  else
    printf "pm open - Open a project\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  pm open [NAME] [OPTIONS]\n"
  printf "  pm open --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--space, -s SPACE"
    printf "    Space where the project is located\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Name of the project\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  pm open recipe\n"
    printf "  pm open editor --space tools\n"
    echo

  fi
}

# :command.usage
pm_filter_usage() {
  if [[ -n $long_usage ]]; then
    printf "pm filter - Filter projects by name\n"
    echo

  else
    printf "pm filter - Filter projects by name\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  pm filter [OPTIONS]\n"
  printf "  pm filter --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--path, -p"
    printf "    Output the full path to the project\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  pm filter\n"
    printf "  pm filter --path\n"
    echo

  fi
}

# :command.usage
pm_space_usage() {
  if [[ -n $long_usage ]]; then
    printf "pm space - Space related commands\n"
    echo

  else
    printf "pm space - Space related commands\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  pm space COMMAND\n"
  printf "  pm space [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Show help about a command\n" "help  "
  printf "  %s   Add a new space\n" "add   "
  printf "  %s   List added spaces\n" "list  "
  printf "  %s   Remove a space (projects will not be removed)\n" "remove"
  printf "  %s   Filter spaces by name\n" "filter"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
pm_space_help_usage() {
  if [[ -n $long_usage ]]; then
    printf "pm space help - Show help about a command\n"
    echo

  else
    printf "pm space help - Show help about a command\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  pm space help [COMMAND]\n"
  printf "  pm space help --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "COMMAND"
    printf "    Help subject\n"
    echo

  fi
}

# :command.usage
pm_space_add_usage() {
  if [[ -n $long_usage ]]; then
    printf "pm space add - Add a new space\n"
    echo

  else
    printf "pm space add - Add a new space\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  pm space add SPACE\n"
  printf "  pm space add --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SPACE"
    printf "    Name of the space to add\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  pm space add personal\n"
    echo

  fi
}

# :command.usage
pm_space_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "pm space list - List added spaces\n"
    echo

  else
    printf "pm space list - List added spaces\n"
    echo

  fi

  printf "Alias: ls\n"
  echo

  printf "%s\n" "Usage:"
  printf "  pm space list\n"
  printf "  pm space list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  pm space ls\n"
    printf "  pm space list\n"
    echo

  fi
}

# :command.usage
pm_space_remove_usage() {
  if [[ -n $long_usage ]]; then
    printf "pm space remove - Remove a space (projects will not be removed)\n"
    echo

  else
    printf "pm space remove - Remove a space (projects will not be removed)\n"
    echo

  fi

  printf "Alias: rm\n"
  echo

  printf "%s\n" "Usage:"
  printf "  pm space remove SPACE\n"
  printf "  pm space remove --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SPACE"
    printf "    Name of the space to remove\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  pm space rm personal\n"
    echo

  fi
}

# :command.usage
pm_space_filter_usage() {
  if [[ -n $long_usage ]]; then
    printf "pm space filter - Filter spaces by name\n"
    echo

  else
    printf "pm space filter - Filter spaces by name\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  pm space filter\n"
  printf "  pm space filter --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  pm space filter\n"
    echo

  fi
}

# :command.usage
pm_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "pm list - List projects\n"
    echo

  else
    printf "pm list - List projects\n"
    echo

  fi

  printf "Alias: ls\n"
  echo

  printf "%s\n" "Usage:"
  printf "  pm list\n"
  printf "  pm list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  pm ls\n"
    printf "  pm list\n"
    echo

  fi
}

# :command.usage
pm_link_usage() {
  if [[ -n $long_usage ]]; then
    printf "pm link - Create a link to the recipe script\n"
    echo

  else
    printf "pm link - Create a link to the recipe script\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  pm link [PATH] [OPTIONS]\n"
  printf "  pm link --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--copy, -c"
    printf "    Copy the script instead of creating a symbolic link\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PATH"
    printf "    Path to the link\n"
    printf "    Default: ${HOME}/.local/bin\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  recipe link -c\n"
    printf "  recipe link /usr/bin\n"
    echo

  fi
}

# :command.usage
pm_unlink_usage() {
  if [[ -n $long_usage ]]; then
    printf "pm unlink - Remove the link to the recipe script\n"
    echo

  else
    printf "pm unlink - Remove the link to the recipe script\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  pm unlink [PATH]\n"
  printf "  pm unlink --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PATH"
    printf "    Path to the link\n"
    printf "    Default: ${HOME}/.local/bin\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  recipe unlink\n"
    echo

  fi
}

# :command.usage
pm_update_usage() {
  if [[ -n $long_usage ]]; then
    printf "pm update - Update to the latest version\n"
    echo

  else
    printf "pm update - Update to the latest version\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  pm update\n"
  printf "  pm update --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  pm update\n"
    echo

  fi
}

# :command.usage
pm_env_usage() {
  if [[ -n $long_usage ]]; then
    printf "pm env - Show environment information\n"
    echo

  else
    printf "pm env - Show environment information\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  pm env\n"
  printf "  pm env --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  pm env\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# src/lib/confirm.sh
confirm() {
    local response=`gum choose --header "${1}" --header.foreground="7" --cursor.foreground="4" 'yes' 'no'`
    [[ "${response}" == "yes" ]] && return 0 || return 1
}

# src/lib/filter_project.sh
filter_project() {
    command fd --type d --max-depth 1 --base-directory "${PM_HOME}" . $(cat "${PM_HOME}/spaces") \
    | sort --unique \
    | gum filter --placeholder "Select a project"
}

# src/lib/filter_project_by_space.sh
filter_project_by_space() {
    command fd --type d --max-depth 1 --base-directory "${PM_HOME}" "${1}" \
        | sort --unique \
        | gum filter --placeholder "Select a project"
}

# src/lib/filter_space.sh
filter_space() {
    command cat "${PM_HOME}/spaces" | gum filter --placeholder "Select a space"
}

# src/lib/filters.sh
filter_recipe_book_healthy() {
    if ! recipe_doctor_command &> /dev/null; then
        echo "$(yellow info:) your recipe book is not correctly setup"
        echo "$(yellow info:) consider running $(yellow_underlined recipe doctor)"
    fi
}

# src/lib/log/error.sh
error() {
    gum log --level="error" --prefix="pm" --prefix.foreground="7" --level.foreground="1" "${1}"
}

# src/lib/log/info.sh
info() {
    gum log --level="info" --prefix="pm" --prefix.foreground="7" --level.foreground="4" "${1}"
}

# src/lib/log/warn.sh
warn() {
    gum log --level="warn" --prefix="pm" --prefix.foreground="7" --level.foreground="3" "${1}"
}

# src/lib/project_exists.sh
project_exists() {
    [[ -d "${PM_HOME}/${1}/${2}" ]] && return 0 || return 1
}

# src/lib/run_silent.sh
run_silent() {
  command ${@} &> /dev/null
}

# src/lib/validations/validate_dir_exists.sh
validate_dir_exists() {
  [[ -d "$1" ]] || echo "must be an existing directory"
}

# src/lib/validations/validate_file_exists.sh
validate_file_exists() {
  [[ -f "$1" ]] || echo "must be an existing file"
}

# src/lib/validations/validate_integer.sh
validate_integer() {
  [[ "$1" =~ ^[0-9]+$ ]] || echo "must be an integer"
}

# src/lib/validations/validate_not_empty.sh
validate_not_empty() {
  [[ -z "$1" ]] && echo "must not be empty"
}

# src/lib/validations/validate_space_exists.sh
validate_space_exists() {
    if [[ ! -d "${PM_HOME}/${1}" ]]; then
        echo "${1} must be an existing space"
        echo -e "\nSee $(yellow_underlined pm space list)"
    fi
}

# src/lib/validations/validate_space_is_missing.sh
validate_space_is_missing() {
    if command rg --quiet "${1}" "${PM_HOME}/spaces"; then
        echo "${1} is already a registered space"
        echo -e "\nSee $(yellow_underlined pm space list)"
    fi
}

# :command.command_functions
# :command.function
pm_help_command() {
  # src/help_command.sh
  command="${args[command]}"
  long_usage=yes

  if [[ -z "$command" ]]; then
    # No command argument, show the global help
    help_function=pm_usage
  else
    # Show the help for the requested command
    help_function="pm_${command}_usage"
  fi

  # Call the help function if it exists
  if [[ $(type -t "$help_function") ]]; then
    "$help_function"
  else
    echo "No help available for this command"
    exit 1
  fi

}

# :command.function
pm_new_command() {
  # src/new_command.sh
  local name="${args[name]}"

  local space="${args[--space]}"
  local template_name="${args[--template]}"

  local project="${space}/${name}"

  local path="${PM_HOME}/${project}"

  if [[ -d "${path}" ]]; then
      error "project '${name}' already exists in space '${space}'."
      exit 1
  fi

  # Search for user templates first
  local template="${HOME}/.config/pm/templates/${template_name}.sh"

  if [[ ! -f "${template}" ]]; then
      # Then search for pm templates
      template="${PM_INSTALL_DIR}/templates/${template_name}.sh"

      if [[ ! -f "${template}" ]]; then
          error "template '${template_name}' not found."
          return 1
      fi
  fi

  if source "${template}" "${space}" "${name}" "${path}"; then
      info "project '${name}' created in space '${space}'."
  else
      error "unable to create project."
      return 1
  fi

  if [[ ! -f "${PM_BACKEND}" ]]; then
      error "backend '${PM_BACKEND}' not found."
      return 1
  fi

  source "${PM_BACKEND}" "${space}" "${name}" "${path}" &> /dev/null

}

# :command.function
pm_clone_command() {
  # src/clone_command.sh
  local repository="${args[repository]}"

  local name="${args[--name]}"
  local space="${args[--space]}"

  [[ -z "${name}" ]] && name="$(basename "${repository}")"

  if [[ -d "${PM_HOME}/${destination}/${name}" ]]; then
      error "space '${space}' already contains this project."
      exit 1
  fi

  local destination="${PM_HOME}/${space}/${name}"

  command git clone "git@github.com:${repository}.git" "$destination"
  info "cloned project in space '${space}' as '${name}'."

}

# :command.function
pm_open_command() {
  # src/open_command.sh
  local name="${args[name]}"
  local space="${args[--space]}"

  if [[ -z "${name}" ]]; then
      if [[ -z "${space}" ]]; then
          project="$(filter_project)"
      else
          project="$(filter_project_by_space "${space}")"
      fi

      name=`basename "${project}"`
      space=`dirname "${project}"`
  else
      if [[ -z "${space}" ]]; then
          error "must use --space flag with argumet NAME."
          return 1
      fi
  fi

  if ! project_exists "${space}" "${name}"; then
      error "no project '${name}' in space '${space}'."
      exit 1
  fi

  if [[ ! -f "${PM_BACKEND}" ]]; then
      error "backend '${PM_BACKEND}' not found."
      return 1
  fi

  local path="${PM_HOME}/${space}/${name}"

  source "${PM_BACKEND}" "${space}" "${name}" "${path}" &> /dev/null

}

# :command.function
pm_filter_command() {
  # src/filter_command.sh
  local path="${args[--path]}"

  local project="$(filter_project)"
  [[ -z "${project}" ]] && exit 1

  [[ -n "${path}" ]] && project="${PM_HOME}/${project}"

  echo "${project}"

}

# :command.function
pm_space_help_command() {
  # src/space_help_command.sh
  command="${args[command]}"
  long_usage=yes

  if [[ -z "$command" ]]; then
    # No command argument, show the global help
    help_function=pm_space_usage
  else
    # Show the help for the requested command
    help_function="pm_space_${command}_usage"
  fi

  # Call the help function if it exists
  if [[ $(type -t "$help_function") ]]; then
    "$help_function"
  else
    echo "No help available for this command"
    exit 1
  fi

}

# :command.function
pm_space_add_command() {
  # src/space_add_command.sh
  local space="${args[space]}"
  local SPACE_INDEX="${PM_HOME}/spaces"

  [[ ! -d "${PM_HOME}/${space}" ]] && command mkdir -p "${PM_HOME}/${space}" &> /dev/null
  echo "${space}" >> "${SPACE_INDEX}"

  command sort --unique "${SPACE_INDEX}" --output "${SPACE_INDEX}"
  info "new space added."

}

# :command.function
pm_space_list_command() {
  # src/space_list_command.sh
  if [[ -f "${PM_HOME}/spaces" ]]; then
      cat "${PM_HOME}/spaces"
  fi

}

# :command.function
pm_space_remove_command() {
  # src/space_remove_command.sh
  local space="${args[space]}"

  local new_spaces=`command rg -vN --color=never "${space}" "${PM_HOME}/spaces"`

  echo "${new_spaces}" > "${PM_HOME}/spaces"
  info "space removed from index"

}

# :command.function
pm_space_filter_command() {
  # src/space_filter_command.sh
  filter_space

}

# :command.function
pm_list_command() {
  # src/list_command.sh
  command fd --type d --max-depth 1 --base-directory "${PM_HOME}" . $(cat "${PM_HOME}/spaces") | sort --unique

}

# :command.function
pm_link_command() {
  # src/link_command.sh
  local path="${args[path]}"
  local copy="${args[--copy]}"

  local source="${PM_INSTALL_DIR}"

  if [[ -f "${path}/pm" ]]; then
      error "there is already a link in ${path}."
      exit 1
  fi

  if [[ ! -d "${source}" ]]; then
      error "source directory ${source} does not exist."
      exit 1
  fi

  if [[ ! -f "${source}/pm" ]]; then
      error "script 'pm' not found in ${source}."
      exit 1
  fi

  local executable=`test -n "${copy}" && echo "cp" || echo "ln -s"`

  command ${executable} "${source}/pm" "${path}/pm"
  info "link created in ${path}."

}

# :command.function
pm_unlink_command() {
  # src/unlink_command.sh
  local path="${args[path]}"

  if [[ -f "${path}/pm" ]]; then
      run_silent rm "${path}/pm"

      info "link removed from ${path}."
  else
      error "no link found in ${path}."
      exit 1
  fi

}

# :command.function
pm_update_command() {
  # src/update_command.sh
  if [[ ! -d "${PM_INSTALL_DIR}" ]]; then
      warn "no pm install directory."
      warn "check documentation for installation instruction."
      exit 1
  fi

  git -C "${PM_INSTALL_DIR}" pull

}

# :command.function
pm_env_command() {
  # src/env_command.sh
  echo "PM_INSTALL_DIR=${PM_INSTALL_DIR}"
  echo "PM_HOME=${PM_HOME}"
  echo "PM_BACKEND=${PM_BACKEND}"

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        pm_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter
  # :command.environment_variables_default
  export PM_INSTALL_DIR="${PM_INSTALL_DIR:-${HOME}/.pm}"
  export PM_HOME="${PM_HOME:-${HOME}/dev}"
  export PM_BACKEND="${PM_BACKEND:-${PM_INSTALL_DIR}/backends/tmux.sh}"

  env_var_names+=("PM_INSTALL_DIR")
  env_var_names+=("PM_HOME")
  env_var_names+=("PM_BACKEND")

  # :command.dependencies_filter
  if command -v git >/dev/null 2>&1; then
    deps['git']="$(command -v git | head -n1)"
  else
    printf "missing dependency: git\n" >&2
    exit 1
  fi

  if command -v fd >/dev/null 2>&1; then
    deps['fd']="$(command -v fd | head -n1)"
  else
    printf "missing dependency: fd\n" >&2
    exit 1
  fi

  if command -v gum >/dev/null 2>&1; then
    deps['gum']="$(command -v gum | head -n1)"
  else
    printf "missing dependency: gum\n" >&2
    exit 1
  fi

  if command -v rg >/dev/null 2>&1; then
    deps['rg']="$(command -v rg | head -n1)"
  else
    printf "missing dependency: rg\n" >&2
    exit 1
  fi

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    help)
      action="help"
      shift
      pm_help_parse_requirements "$@"
      shift $#
      ;;

    new)
      action="new"
      shift
      pm_new_parse_requirements "$@"
      shift $#
      ;;

    clone)
      action="clone"
      shift
      pm_clone_parse_requirements "$@"
      shift $#
      ;;

    open)
      action="open"
      shift
      pm_open_parse_requirements "$@"
      shift $#
      ;;

    filter)
      action="filter"
      shift
      pm_filter_parse_requirements "$@"
      shift $#
      ;;

    space)
      action="space"
      shift
      pm_space_parse_requirements "$@"
      shift $#
      ;;

    list | ls)
      action="list"
      shift
      pm_list_parse_requirements "$@"
      shift $#
      ;;

    link)
      action="link"
      shift
      pm_link_parse_requirements "$@"
      shift $#
      ;;

    unlink)
      action="unlink"
      shift
      pm_unlink_parse_requirements "$@"
      shift $#
      ;;

    update)
      action="update"
      shift
      pm_update_parse_requirements "$@"
      shift $#
      ;;

    env)
      action="env"
      shift
      pm_env_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      pm_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
pm_help_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        pm_help_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="help"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['command']+x} ]]; then
          args['command']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
pm_new_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        pm_new_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="new"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --space | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--space']="$2"
          shift
          shift
        else
          printf "%s\n" "--space requires an argument: --space, -s SPACE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --template | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--template']="$2"
          shift
          shift
        else
          printf "%s\n" "--template requires an argument: --template, -t TEMPLATE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: pm new NAME [OPTIONS]\n" >&2
    exit 1
  fi

  # :command.required_flags_filter
  if [[ -z ${args['--space']+x} ]]; then
    printf "missing required flag: --space, -s SPACE\n" >&2
    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--template']:-} ]] || args['--template']="default"

  # :command.validations
  # :flag.validations
  if [[ -v args['--space'] && -n $(validate_space_exists "${args['--space']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "--space, -s SPACE" "$(validate_space_exists "${args['--space']:-}")" >&2
    exit 1
  fi

}

# :command.parse_requirements
pm_clone_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        pm_clone_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="clone"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --space | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--space']="$2"
          shift
          shift
        else
          printf "%s\n" "--space requires an argument: --space, -s SPACE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --name | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--name']="$2"
          shift
          shift
        else
          printf "%s\n" "--name requires an argument: --name, -n NAME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['repository']+x} ]]; then
          args['repository']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['repository']+x} ]]; then
    printf "missing required argument: REPOSITORY\nusage: pm clone REPOSITORY [OPTIONS]\n" >&2
    exit 1
  fi

  # :command.required_flags_filter
  if [[ -z ${args['--space']+x} ]]; then
    printf "missing required flag: --space, -s SPACE\n" >&2
    exit 1
  fi

  # :command.validations
  # :flag.validations
  if [[ -v args['--space'] && -n $(validate_space_exists "${args['--space']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "--space, -s SPACE" "$(validate_space_exists "${args['--space']:-}")" >&2
    exit 1
  fi

}

# :command.parse_requirements
pm_open_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        pm_open_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="open"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --space | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--space']="$2"
          shift
          shift
        else
          printf "%s\n" "--space requires an argument: --space, -s SPACE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.validations
  # :flag.validations
  if [[ -v args['--space'] && -n $(validate_space_exists "${args['--space']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "--space, -s SPACE" "$(validate_space_exists "${args['--space']:-}")" >&2
    exit 1
  fi

}

# :command.parse_requirements
pm_filter_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        pm_filter_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="filter"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --path | -p)

        # :flag.case_no_arg
        args['--path']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
pm_space_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        pm_space_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    help)
      action="help"
      shift
      pm_space_help_parse_requirements "$@"
      shift $#
      ;;

    add)
      action="add"
      shift
      pm_space_add_parse_requirements "$@"
      shift $#
      ;;

    list | ls)
      action="list"
      shift
      pm_space_list_parse_requirements "$@"
      shift $#
      ;;

    remove | rm)
      action="remove"
      shift
      pm_space_remove_parse_requirements "$@"
      shift $#
      ;;

    filter)
      action="filter"
      shift
      pm_space_filter_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      pm_space_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
pm_space_help_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        pm_space_help_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="space help"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['command']+x} ]]; then
          args['command']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
pm_space_add_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        pm_space_add_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="space add"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['space']+x} ]]; then
          args['space']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['space']+x} ]]; then
    printf "missing required argument: SPACE\nusage: pm space add SPACE\n" >&2
    exit 1
  fi

  # :command.validations
  # :argument.validations
  if [[ -v args['space'] && -n $(validate_space_is_missing "${args['space']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "SPACE" "$(validate_space_is_missing "${args['space']:-}")" >&2
    exit 1
  fi

}

# :command.parse_requirements
pm_space_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        pm_space_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="space list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
pm_space_remove_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        pm_space_remove_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="space remove"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['space']+x} ]]; then
          args['space']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['space']+x} ]]; then
    printf "missing required argument: SPACE\nusage: pm space remove SPACE\n" >&2
    exit 1
  fi

  # :command.validations
  # :argument.validations
  if [[ -v args['space'] && -n $(validate_space_exists "${args['space']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "SPACE" "$(validate_space_exists "${args['space']:-}")" >&2
    exit 1
  fi

}

# :command.parse_requirements
pm_space_filter_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        pm_space_filter_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="space filter"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
pm_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        pm_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
pm_link_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        pm_link_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="link"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --copy | -c)

        # :flag.case_no_arg
        args['--copy']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['path']+x} ]]; then
          args['path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['path']:-} ]] || args['path']="${HOME}/.local/bin"

}

# :command.parse_requirements
pm_unlink_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        pm_unlink_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="unlink"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['path']+x} ]]; then
          args['path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['path']:-} ]] || args['path']="${HOME}/.local/bin"

}

# :command.parse_requirements
pm_update_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        pm_update_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="update"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
pm_env_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        pm_env_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="env"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  version="1.4.0"
  long_usage=''
  set -e

  # :command.environment_variables_default
  export PM_INSTALL_DIR="${PM_INSTALL_DIR:-${HOME}/.pm}"
  export PM_HOME="${PM_HOME:-${HOME}/dev}"
  export PM_BACKEND="${PM_BACKEND:-${PM_INSTALL_DIR}/backends/tmux.sh}"

  # src/initialize.sh
  local SPACE_INDEX="${PM_HOME}/spaces"

  [[ ! -d "${PM_HOME}" ]] && command mkdir -p "${PM_HOME}"
  [[ ! -f "${SPACE_INDEX}" ]] && touch "${SPACE_INDEX}"

  # Create directories if not present
  for space in $(cat "${SPACE_INDEX}"); do
      [[ ! -d "${PM_HOME}/${space}" ]] && command mkdir -p "${PM_HOME}/${space}"
  done

  command sort --unique "${SPACE_INDEX}" --output "${SPACE_INDEX}"

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a env_var_names=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "help") pm_help_command ;;
    "new") pm_new_command ;;
    "clone") pm_clone_command ;;
    "open") pm_open_command ;;
    "filter") pm_filter_command ;;
    "space") pm_space_command ;;
    "space help") pm_space_help_command ;;
    "space add") pm_space_add_command ;;
    "space list") pm_space_list_command ;;
    "space remove") pm_space_remove_command ;;
    "space filter") pm_space_filter_command ;;
    "list") pm_list_command ;;
    "link") pm_link_command ;;
    "unlink") pm_unlink_command ;;
    "update") pm_update_command ;;
    "env") pm_env_command ;;
  esac
}

initialize
run "$@"
